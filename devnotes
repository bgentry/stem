Workflow Outline
----------------

$ vi dedicated
{
 ami: "ami-xxx"
 volumes: ["/dev/sde1", "128"]
 userdata: "myuserdata.sh"
}
$ easy initialize dedicated dedicated.easy
Storing version X of dedicated.... done.
Creating volumes.... done.
Snapshotting template volumes...... done.
Booting a "dedicated" server....... done.
$ easy 

$ easy bootfrom existing-stopped-instance new-instance --specific-size ? --specific-az

Missing
-----------
how to boot older versions of the config (not easy's problem?)

Creating the Prototype
---------------------------
- in `easy` on your local machine
   store the prototype config in a safe place
   create any necessary volumes via CreateVolume (raid0 group + wal, defined in the slot config)
   RunInstance "base-ami", EBS_VOLUME_OPTIONS (/dev/sdf{1..8}, /dev/sde1)
   provide a userdata/init.sh

- CreateImage on the instance

* This process is not 32/64 swappable easily.
* Passing thought: do we actually need a wal volume? why not ramdisk, since it's being stored in s3 anyway?
* XXXTODO: don't let the root ebs volume get gnarshed

Creating an Instance
--------------------
- "RunInstance", "InstanceId" => "prototype-ami", PROTOTYPE_EBS_OPTIONS, "InstanceType" => "m1.samearch", "AvailabilityZone" => "where-ever-1a", "UserData", `cat userdata/config.sh`
- in userdata/config.sh
  -- set any instance specific data, such as PG_ROLE/PG_PASSWORD

Restarting an Instance
----------------------
- "RunInstance" exactly as shown above with userdata/restart.sh (or even... nothing!)

Restoring an Instance
---------------------
- "RunInstance" exactly as above EXCEPT with userdata/restore.sh
- in userdata/restore.sh
 -- pull down whatever restore stuff you want to do
 -- take a fresh set of backups & retire the old ones. (danger! danger!)

##############
Swirl
##############
>> pp c.call "RunInstances", "ImageId"=>"ami-243fd74d", "KeyName"=>"default", "MinCount"=>"1", "MaxCount"=>"1",
  "BlockDeviceMapping.#.Ebs.SnapshotId"=>["snap-f9b39991", "snap-0fb39967", "snap-1bb39973", "snap-13b3997b", "snap-efb39987", "snap-dbb399b3", "snap-bbb399d3", "snap-b3b399db", "snap-8db399e5"],
  "BlockDeviceMapping.#.DeviceName"    =>["/dev/sde1",     "/dev/sdf1",     "/dev/sdf2",     "/dev/sdf3",     "/dev/sdf4",     "/dev/sdf5",     "/dev/sdf6",     "/dev/sdf7",     "/dev/sdf8"]

What do we need to store?
--------------------
the prototype AMI
we want to be able to recreate that AMI
 so - anything necessary for that (doesn't have to be part of the service though)

>> >> opt = opt.merge( { "UserData" =>)
=> {"ImageId"=>"ami-714ba518", "KeyName"=>"default", MaxCount"=>"1", "BlockDeviceMapping.#.Ebs.SnapshotId"=>["snap-4543762d", "snap-59437631", "snap-5d437635", "snap-5f437637", "snap-51437639", "snap-5343763b", "snap-5543763d", "snap-5743763f", "snap-29437641"], "BlockDeviceMapping.#.DeviceName"=>["/dev/sde1", "/dev/sdf1", "/dev/sdf2", "/dev/sdf3", "/dev/sdf4", "/dev/sdf5", "/dev/sdf6", "/dev/sdf7", "/dev/sdf8"], "MinCount"=>"1",  "UserData"=> Base64.encode64( File.read('/Users/pvh/Development/DoD/init_userdata.sh') )}
>> pp c.call "RunInstances", opt

